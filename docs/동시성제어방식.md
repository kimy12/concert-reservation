# 동시성 제어 방식

- - -

콘서트 예약 시스템을 개발하며 크게 두 API에서 동시성 이슈가 발생한다. 첫번째로는 좌석 선점 및 예약이다. 인기 콘서트의 경우에는,
콘서트 예약 오픈시에 많은 사람들이 한거번에 몰리게 될 수있다. 

두번째는, 포인트 충전 및 결제 이다. 서버가 요청을 처리하는 동안, 
두 개 이상의 요청이 중첩되어 처리되면서 동시성 문제가 발생할 수 있다. 

이에 데이터의 무결성이 깨질 위험이있어, 동시성 문제 해결방법에 대한 고민이 필요하며, 각 비지니스 로직에 적합한 동시성 처리 방식에 대한 고민도 필요하다. 

## 1. 낙관적 락

- 기본적으로 데이터 갱신 시 충돌이 발생하지 않을 것이라고 낙관적으로 보는 락이다.
- db 레벨에서 적용하는 락이 아니며, 어플리케이션 레벨에서 적용한다.
- 낙관적락은 JPA가 제공하는 버전 관리 기능을 사용할 수 있다.
- version을 통해 관리 할 수 있으며, 최초 한 요청 (update) 만 성공하고 나머지 요청들은 실패처리되며, 이에 관한 로직 구현이 필요하다.
- 낙관적락을 JPA에서 사용하기 위해서는 @Version을 엔티티에 추가해서 사용한다.
````
@Version
private long version;
````
- 위와 같이 버전 관리용 필드를 추가해 트랜잭션 내에서 처음 조회되었을때의 버전과 트랜잭션이 종료될 때의 버전을 비교하여 버전이 다를 경우 ObjectOptimisticLockingFailureException 예외를 발생시킨다.


## 2. 비관적 락

- 기본적으로 데이터 갱신시 충돌이 발생할 것이라고 비관적으로 생각하며 미리 잠금을 거는 락이다. 따라서 데이터 무결성은 강하게 보장하지만, 동시성 처리 성능이 낮아질 수 있다.
- db레벨에서 적용하는락이며, 실패할 경우 트랜젝션 전체에 자동으로 rollback을 해 준다.
- 레코드에 배타락(x-Lock)을 건다. 다른 트랜잭션은 해당 데이터에 대한 읽기/쓰기 연산 모두 불가능하게 된다.


````
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT cs " +
        "FROM ConcertSeat cs " +
        "WHERE cs.seatNumber = :seatNumber " +
        "AND cs.scheduleId = :scheduleId " +
        "AND (cs.status = :status OR cs.status is null)")
Optional<ConcertSeat> findBySeatNumberAndScheduleIdAndStatus(@Param("seatNumber") Long seatNumber, @Param("scheduleId")Long scheduleId,@Param("status") ConcertSeatStatus status);
````

## 3. 분산 락

- 분산락이란 멀티스레드 환경에서 공유 자원을 접근 할 때 공유 자원에 대한 동서성 문제를 제어 하기 위해 사용되는 락이다.
- 분산락 구현방법은 Zookeeper, MySQL, Redis 등이 있다.

## Redis

> 분산락을 처리하기 위해서는 여러가지 방법이 있지만 Redis를 사용한 이유는 크게 두가지가 있다. 
> 1. 빠른 응답 시간 : 레디스는 메모리 기반의 데이터 베이스로 매우 빠른 속도로 읽고 쓸 수 있다.
> 2. 내장된 락 기능 : 레디스에서 분산락을 구현하기 위한 메서드를 제공하고 있다.
>
> Redis를 사용하여 동시성 문제를 해결하는 대표적인 라이브러리는 2가지가 존재한다.

### Lettuce

- Lettuce는 Netty 기반의 Redis Client 이며, 요청을 Non-Blocking 으로 처리한다
- SETNX 명령어를 통해서 분산락을 구현할 수 있다.
- Spin Lock 방식. 지속적으로 Redis에게 락이 해제되었는지 요청을 보내는 방식으로, 요청이 많아질 수록 Redis가 받는 부하는 커지게 된다.

### Redisson
- Pub/Sub 방식을 이용하기에 락이 해제되면 락을 subscribe 하는 클라이언트는 락이 해제되었다는 신호를 받고 락 획득을 시도한다.
- 클라이언트가 락 획득을 실패했을 때, Redis에 지속적으로 락 획득 요청을 보내는 과정이 사라지고, 이에 따라 부하가 발생하지 않는다.


### 레디스와 트랜잭션
- 레디스를 적용하여 분산락을 구현할때 트랜젝션은 아래와 같이 수행됨이 보장되어야 한다.
````
락 획득 -> 트랜잭션 시작 -> 비즈니스 로직 수행 -> 트랜잭션 종료 -> 락 해제
````

따라서, 분산락의 트랜잭션은 부모 트랜잭션과 무관하게 별도의 트랜잭션으로 동작하도록 구현해야 한다. 만약, 분산락 트랜잭션이 부모 트랜잭션과 동일한 트랜잭션에서 수행된다면, 락은 부모트랜잭션이 종료됨과 동시에 해제되며,
이렇게 되는경우에는 락이 해제된 이후에도 변경 전 데이터를 조회 하게 되어 데이터의 정합성이 깨질 수 있다.



- - -

## 락 선정 내용

위와 같은 내용을 바탕으로 내가 고안한 로직별 적절한 동시성 문제 해결 방안은 아래와 같다.

1. 콘서트 예약 (좌석 선점)
- 낙관적락 선택
- 대기열을 운영하기 때문에 충돌 가능성이 낮으며, 충돌 발생 시 재시도 없이 실패 처리로 충분하다.
- 대기열에서 순차적으로 예약 시도를 하기 때문에 낙관적 락으로도 데이터 정합성을 충분히 보장 가능하다.

2. 포인트 결제
- 분산락 선택
- 위에서 언급했듯이 트랜잭션의 독립성을 보장하기 위해, 분산 락의 처리 로직은 별도의 트랜잭션에서 동작하는데, 이를 통해 락 해제 시점과 비지니스 로직의 실행 순서가 꼬이는 문제를 방지하도록 구현했다.
- 분산락 처리 로직과 비지니스 로직을 분리해 재사용성을 높히기 위해서 AOP로 구현했다.
- 분산락 처리 방법 중 Redisson을 사용한 이유는, 개발자가 직접 재시도 로직을 구현할 필요가 없으며, 락 획득, 해제 타임아웃 등의 관리 로직을 자동으로 처리해 주어 관련된 구현을 할 필요가 없다.

3. 포인트 충전
- 비관적락 선택
- 사용자 계좌의 데이터 무결성을 보장해야 하는 만큼 비관적락을 통해 충돌 가능성을 사전에 차단하기 위해 선택했다.
- 비관적 락은 동시성 처리 성능이 낮아질 수 있지만, 포인트 충전 작업은 빈번하지 않고 하나의 사용자에 대해 동시에 처리되는 요청이 제한적이기 때문에 성능 저하의 영향이 크지 않다고 판단했다.



